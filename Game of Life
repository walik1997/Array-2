#Time COmplexity -O(m×n)
#Space Complexity -O(m×n)
# Did this code successfully run on Leetcode : Yes
# Any problem you faced while coding this : No

# Your code here along with comments explaining your approach: Used a directional array to check neighb elements. The change from 1 to 0 is recorded as 4 and 3 is used for the change otherway so that the main matrix is not altered
#then checked the game condition and finally created a loop to finally reflect the changes in same matrix



class Solution:
    def gameOfLife(self, board: List[List[int]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        def count(board, i,j):
            directions=[[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]
            count=0
            for dir in directions:
                nr=i+dir[0]
                nc=j+dir[1]
                if nr >= 0 and nr < len(board) and nc >= 0 and nc < len(board[0]) and (board[nr][nc] == 4 or board[nr][nc] == 1):
                    count += 1
            return count
        
        for i in range(len(board)):
            for j in range(len(board[0])):
                live=count(board,i,j)
                if board[i][j] ==1:
                    if live<2 or live>3:
                        board[i][j]=4
                    if live ==2 or live==3:
                        continue
                else:
                    if live ==3:
                        board[i][j]=3
        for i in range(len(board)):
            for j in range(len(board[0])):
                if board[i][j]==3:
                    board[i][j]=1
                if board[i][j]==4:
                    board[i][j]=0                